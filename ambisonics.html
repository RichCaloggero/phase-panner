<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta charset="utf-8">
<title>Ambisonics</title>
<style>
label {display: block;}
</style>
</head>

<body>
<h1>Test</h1>

<div id="controls">
<div class="player">
<h2>Audio Player</h2>
<label>audio: <input type="text" id="audioFile" value="t1.mp3" accesskey="f"></label>
<button id="load" accesskey="l">Load</button>
<br><audio tabindex="0" controls accesskey="a"></audio>
</div>

<div id="parameters">
<div>
<h2>Save and restore</h2>
<button id="save" accesskey="s">Save</button>
<button id="restore" accesskey="r">Restore</button>
</div>

<div id="position">
<h2>Position</h2>
<label>azimuth: <input type="range" id="azim" min="-180" max="180" accesskey="a"></label>
<label>elevation: <input type="range" id="elev" min="-90" max="90" accesskey="e"></label>
</div>

<div id="rotation">
<h2>Rotation</h2>
<label>roll: <input type="range" id="roll" min="-90" max="90" accesskey="r"></label>
<label>pitch: <input type="range" id="pitch" min="-90" max="90" accesskey="p"></label>
<label>yaw: <input type="range" id="yaw" min="-90" max="90" accesskey="y"></label>
</div>

<div id="xtc">
<h2>XTC</h2>

<label>binaural / unprocessed mix: <input type="range" id="mix-binaural-unprocessed" value="0" min="0" max="1" step="0.1" accesskey="m"></label>
<label>xtc  mix: <input type="range" id="mix-xtc" value="0" min="0" max="1" step="0.1"></label>
<label>frequency: <input type="range" id="frequency" value="1000" min="40" max="10000" step="20" accesskey="f"></label>
<label>q: <input type="range" id="q" value="1" min="0" max="8" step="0.1" accesskey="q"></label>
<label>delay: <input type="range" id="delay" value="0.000250" min="0" max="0.01" step="0.00025"></label>
<label>makeup filter gain: <input type="range" id="makeupFilterGain" value="1" min="0" max="3" step="0.1" accesskey="+"></label>
<label>makeup filter frequency: <input type="range" id="makeupFrequency" value="1000" min="40" max="10000" step="20"></label>
<label>makeup filter q: <input type="range" id="makeupQ" value="1" min="0" max="10" step="0.1"></label>
</div><!-- #xtc -->

</div><!-- #parameters -->
</div><!-- #controls -->

<div id="message" aria-live="polite"></div>

<script src="ambisonics.umd.js"></script>
<script src="ui.js"></script>
<script>
const audio = new AudioContext();
const audioElement = document.querySelector("audio");
const inLeft = new ambisonics.monoEncoder(audio, 3);
const inRight = new ambisonics.monoEncoder(audio, 3);
const rotator = new ambisonics.sceneRotator(audio, 3);
const binauralProcessor = new ambisonics.binDecoder(audio, 3);
const automation = {running: false};

/// create nodes
const player = audio.createMediaElementSource (audioElement);
const binauralDry = audio.createGain();
const binauralWet = audio.createGain();
const binauralIn = audio.createGain();
const binauralOut = audio.createGain();
const s = audio.createChannelSplitter(2);
const m = audio.createChannelMerger(2);


/// ambisonic connections
player.connect(binauralIn);
binauralIn.connect(binauralDry);
binauralIn.connect(s);

s.connect(inLeft.in,0);
s.connect(inRight.in, 1);

inLeft.out.connect(rotator.in);
inRight.out.connect(rotator.in);
rotator.out.connect(binauralProcessor.in);
binauralProcessor.out.connect(binauralWet);

binauralDry.connect(binauralOut);
binauralWet.connect(binauralOut);

/// xtc
const xtcIn = audio.createGain();
const xtcOut = audio.createGain();
const xWet = audio.createGain();
const xDry = audio.createGain();
const l = audio.createGain();
const r = audio.createGain();
const xs = audio.createChannelSplitter(2);
const xm = audio.createChannelMerger(2);
const xf = audio.createBiquadFilter();
const xdl = audio.createBiquadFilter();
const xdr = audio.createBiquadFilter();
const xDryDelay = audio.createDelay();
const xMakeupFilter = audio.createBiquadFilter();

// xtc connections

binauralOut.connect(xtcIn);

xtcIn.connect(xDryDelay).connect(xDry);
xtcIn.connect(xf).connect(xs);

xs.connect(l, 0,0).connect(xdl).connect(xm, 0,1);
xs.connect(r, 1,0).connect(xdr).connect(xm, 0,0);

xm.connect(xMakeupFilter).connect(xWet);

xDry.connect(xtcOut);
xWet.connect(xtcOut);
xtcOut.connect(audio.destination);

// set values
xf.type = "bandpass";
xdl.type = xdr.type = "allpass";
xMakeupFilter.type = "lowshelf";
l.gain.value = -1
r.gain.value = 1;


/// initialize
const HOA3loader = new ambisonics.HOAloader(audio, 3, "HOA3_IRC_1008_virtual.wav",
data => binauralProcessor.updateFilters(data));
HOA3loader.load();
updateAll ();

load();



function fixNumberInputs () {
Array.from(document.querySelectorAll("input[type='number']"))
.forEach(x => x.setAttribute("aria-label", x.parentElement.textContent));
} // fixNumberInputs

function load (autoPlay) {
audioElement.src = document.querySelector("#audioFile").value;
if (autoPlay) audioElement.play();
} // load


/// events

document.querySelector("#load").addEventListener("click", load);
document.querySelector("#save").addEventListener("click", save);
document.querySelector("#restore").addEventListener("click", restore);

document.querySelector("#parameters").addEventListener("keydown", (e) => {
if (e.key === "0" && e.target.type && e.target.type === "range") {
e.target.value = 0;
e.target.dispatchEvent(new CustomEvent("change", {bubbles: true}));
} // if
});

document.querySelector("#controls").addEventListener("change", (e) => update(e.target.id, getValue(e.target.id)));


function updateXtc (element) {
if (element) {
update(element.id, getValue(element.id));
} else {
Array.from(document.querySelector("#xtc input"))
.forEach(element => update(element.id, getValue(element.id)));
} // if
} // updateXtc

function updateAll () {
enumerateUiControls().forEach(element => update(element.id, getValue(element.id)));
} // updateAll

function update (id, value) {
console.log(`update: ${id}, ${value}`);
if (!id) return;

const map = {
depth: automation,
rate: automation,
phase: automation,

azim: updatePosition,
elev: updatePosition,
roll: updateRotator,
pitch: updateRotator,
yaw: updateRotator,

delay: [xDryDelay.delayTime],
frequency: [xf.frequency, xdl.frequency, xdr.frequency],
q: [xf.Q, xdl.Q, xdr.Q],
makeupFilterGain: [xMakeupFilter.gain],
makeupFrequency: [xMakeupFilter.frequency],
makeupQ: [xMakeupFilter	.Q],

"mix-binaural-unprocessed": function (id, value) {
binauralDry.gain.value = 1 - value;
binauralWet.gain.value = value;
binauralOut.gain.value = 1 + (2 * binauralWet.gain.value);
},

"mix-xtc": function (id, value) {
xDry.gain.value = 1 - value;
xWet.gain.value = value;
xMakeupFilter.gain.value = 2 * value;

xtcOut.gain.value = 1 + (2.5 * value);
} // mix-xtc
}; // map

return run(map[id], id, value);

function run (it, id, value) {
//console.log(`it: ${it}`);
if (!it) {
console.log(`run: ${id} not found`);
return;

} else if (it instanceof Array) {
//console.log(`run: processing array of length ${it.length}`);
it.forEach(object => run(object, id, value));

} else if (it instanceof Function) {
//console.log(`run: calling ${it}(${id}, ${value});`);
return it(id, value);

} else if (it instanceof Object && "value" in it) {
//console.log(`run: assigning ${it}.value = ${value}`);
it.value = value;

}else if (it instanceof Object && id in it) {
//console.log(`run: assigning ${it}.${id} = ${value}`);
it[id] = value;

 } else {
console.log(`run: cannot process ${id}, ${value}`);
return;
} // if
} // run

function updatePosition (id, value) {
const left = Number(value);
const prop = id;
inLeft[prop] = left;
inRight[prop] = -1*left;
inLeft.updateGains();
inRight.updateGains();
} // updatePosition

function updateRotator (id, value) {
const prop = id;
rotator[prop] = value;
rotator.updateRotMtx();
} // updateRotator

} // update


/// automation

function automate (automator) {
if (automation.running) {
setTimeout(function _tick () {
automator(audio.currentTime, automation);
if (automation.running) setTimeout(_tick, getValue("tick"));
}, getValue("tick"));
} // if
} // automate

function automator (t, automation) {
const pi = Math.PI;
const sin = Math.sin;
const cos = Math.cos;
//const phase = Math.random()*pi;
const func = t => getValue("depth") * sin(t + getValue("phase"));


} // automator


function save () {
localStorage.userValues = JSON.stringify(
enumerateUiControls()
.map(x => [x.id, x.value])
);
} // save

function restore () {
try {
JSON.parse(localStorage.userValues)
.forEach (x => {
const [id, value] = x;
const element = document.getElementById(id);
element.value = value;
element.dispatchEvent(new CustomEvent("change", {bubbles: true}));
}); // forEach
} catch (e) {
alert (`Cannot restore: ${e}.`);
} // try
} // restore


function message (...args) {
_message(args.join(", "));

function _message (text) {
document.querySelector("#message").textContent = text;
return text;
} // _message
} // message

</script>

</body>
</html>
