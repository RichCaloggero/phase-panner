<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta charset="utf-8">
<title>pannernode test</title>
<style>
label {display: block;}
</style>
</head>

<body>
<h1>Test</h1>

<div id="controls">
<div class="player">
<h2>Audio Player</h2>
<label>audio: <input type="text" id="audioFile" value="t1.mp3" accesskey="f"></label>
<button id="load" accesskey="l">Load</button>
<br><audio tabindex="0" controls accesskey="a"></audio>
</div>

<div id="parameters">
<div>
<h2>Save and restore</h2>
<button id="save" accesskey="s">Save</button>
<button id="restore" accesskey="r">Restore</button>
</div>

<div id="position">
<h2>Position</h2>
<label>panning model: <input type="text" id="panningModel" value="HRTF"></label>
<label>angle: <input type="range" id="angle" min="0" step="0.02" accesskey="a"></label>
<label>radius: <input type="range" id="radius" min="-90" max="90" step="0.1"></label>
</div>

<div id="automation">
<h2>Automation</h2>

<label>enable automation: <input id="enableAutomation" type="checkbox" checked></label>
<label>automate parameter: <select id="parameterName" accesskey="p"></select></label>
<label>function: <input type="text" id="function"></label>
<label>enable <input type="checkbox" id="automate"></label>
<label>tick: <input type="range" id="tick" value="0.2" min=".0.02" max="0.5" step="0.01"></label>

</div>

<div id="xtc">
<h2>XTC</h2>

<label>binaural / unprocessed mix: <input type="range" id="mix-binaural-unprocessed" value="0" min="0" max="1" step="0.1" accesskey="m"></label>
<label>xtc  mix: <input type="range" id="mix-xtc" value="0" min="0" max="1" step="0.1"></label>
<label>feedback: <input type="range" id="feedback" value="0" min="-1" max="1" step="0.1" accesskey="b"></label>
<label>type: <input type="text" id="type" value="bandpass"t"></label>
<label>frequency: <input type="range" id="frequency" value="1500" min="40" max="10000" step="20" accesskey="f"></label>
<label>q: <input type="range" id="q" value=".3" min="0" max="8" step="0.1" accesskey="q"></label>
<label>delay: <input type="range" id="delay" value="0.00003" min="0" max="1" step="0.000020" accesskey="d"></label>
</div><!-- #xtc -->

</div><!-- #parameters -->
</div><!-- #controls -->

<div id="message" aria-live="polite"></div>

<script src="delay.js"></script>
<script src="ambisonics.umd.js"></script>
<script src="ui.js"></script>
<script>
const audio = new AudioContext();
const audioElement = document.querySelector("audio");

const leftPanner = audio.createPanner(), rightPanner = audio.createPanner();

const fdProcessor = new FractionalDelay(audio.sampleRate, 1.0);
const automation = {};
let projectName = "default.txt";

/// create nodes
const player = audio.createMediaElementSource (audioElement);
const binauralDry = audio.createGain();
const binauralWet = audio.createGain();
const binauralIn = audio.createGain();
const binauralOut = audio.createGain();
const s = audio.createChannelSplitter(2);
const m = audio.createChannelMerger(2);


/// ambisonic connections
player.connect(binauralIn);
binauralIn.connect(binauralDry);
binauralIn.connect(s);

s.connect(leftPanner, 0).connect(binauralWet);
s.connect(rightPanner, 1).connect(binauralWet);

binauralDry.connect(binauralOut);
binauralWet.connect(binauralOut);

/// xtc
const xtcIn = audio.createGain();
const xtcOut = audio.createGain();
const xWet = audio.createGain();
const xDry = audio.createGain();
const l = audio.createGain();
const r = audio.createGain();
const xs = audio.createChannelSplitter(2);
const xm = audio.createChannelMerger(2);
const xf = audio.createBiquadFilter();
const xdl = audio.createDelay();
const xdr = audio.createDelay();
const xLFeedback = audio.createGain(), xRFeedback = audio.createGain();
const xDryDelay = audio.createDelay();
const xMakeupFilter = audio.createBiquadFilter();

// xtc connections

binauralOut.connect(xtcIn);

xtcIn.connect(xDry);
xtcIn.connect(xf).connect(xs);

xs.connect(l, 0,0).connect(xdl).connect(xm, 0,1);
xs.connect(r, 1,0).connect(xdr).connect(xm, 0,0);

xdl.connect(xLFeedback).connect(rightPanner);
xdr.connect(xRFeedback).connect(leftPanner);

xm.connect(xWet);

xDry.connect(xtcOut);
xWet.connect(xtcOut);
xtcOut.connect(audio.destination);

// set values
leftPanner.panningModel = rightPanner.panningModel = "HRTF";
l.gain.value = r.gain.value = -1;


/// initialize
initializeAutomation();
updateAll ();

load();



function fixNumberInputs () {
Array.from(document.querySelectorAll("input[type='number']"))
.forEach(x => x.setAttribute("aria-label", x.parentElement.textContent));
} // fixNumberInputs

function load (autoPlay) {
audioElement.src = document.querySelector("#audioFile").value;
if (autoPlay) audioElement.play();
} // load


/// events

document.querySelector("#load").addEventListener("click", load);
document.querySelector("#save").addEventListener("click", save);
document.querySelector("#restore").addEventListener("click", restore);

document.querySelector("#parameters").addEventListener("keydown", (e) => {
if (e.key === "0" && e.target.type && e.target.type === "range") {
e.target.value = 0;
e.target.dispatchEvent(new CustomEvent("change", {bubbles: true}));
} // if
});

document.querySelector("#controls").addEventListener("change", (e) => update(e.target.id, getValue(e.target.id)));



function updateAll () {
enumerateUiControls().forEach(element => update(element.id, getValue(element.id)));
} // updateAll

function update (id, value) {
//console.log(`update: ${id}, ${value}`);
if (!id) return;

const map = {
angle: updatePosition,
radius: updatePosition,
delay: function (id, value) {
fdProcessor.setDelay(Number(value));
}, // delay

enableAutomation: function (id, value) {
automation.enabled = value;
if (automation.enabled) {
console.log("starting automation...");
runAutomation(automation, automator);
} // if
}, // enableAutomation

parameterName: function (id, value) {
const parameter = automation.parameters.get(value);
console.log("selectParameter: ", value, parameter);
ui("automate").checked = parameter.enabled;
ui("function").value = parameter.functionText;
}, // parameterName

function: function (id, value) {
const parameterName = getValue("parameterName");
const parameter = automation.parameters.get(parameterName);
parameter.functionText = value;
if (value) parameter.function = compile(value);
}, // function

automate: function (id, value) {
const parameterName = getValue("parameterName");
const parameter = automation.parameters.get(parameterName);
parameter.enabled = value;
console.log("automate: ", value, parameter);
}, // automate

tick: {automation},

feedback: [xLFeedback.gain, xRFeedback.gain],
type: [xf],
frequency: [xf.frequency],
q: [xf.Q],
panningModel: [leftPanner, rightPanner],

"mix-binaural-unprocessed": function (id, value) {
binauralDry.gain.value = 1 - value;
binauralWet.gain.value = value;
binauralOut.gain.value = 1 + .3 * value;
},

"mix-xtc": function (id, value) {
xDry.gain.value = 1 - value;
xWet.gain.value = value;
xtcOut.gain.value = 1 + (2.5 * value);
} // mix-xtc
}; // map

return run(map[id], id, value);

function run (it, id, value) {
//console.log(`it: ${it}`);
if (!it) {
console.log(`run: ${id} not found`);
return;

} else if (it instanceof Array) {
//console.log(`run: processing array of length ${it.length}`);
it.forEach(object => run(object, id, value));

} else if (it instanceof Function) {
//console.log(`run: calling ${it}(${id}, ${value});`);
return it(id, value);

} else if (it instanceof Object && "value" in it) {
//console.log(`run: assigning ${it}.value = ${value}`);
it.value = value;

}else if (it instanceof Object && id in it) {
//console.log(`run: assigning ${it}.${id} = ${value}`);
it[id] = value;

} else {
console.log(`run: cannot process ${id}, ${value}`);
return;
} // if
} // run

function updatePosition (id, value) {
const a = id === "angle"? value : getValue("angle");
const r = id === "radius"? value : getValue("radius");
setPosition(a, r);
} // updatePosition

function setPosition (a, r) {
leftPanner.positionX.value = r*Math.cos(a);
leftPanner.positionY.value = r*Math.sin(a);
leftPanner.positionZ.value = r*Math.cos(a+a/3+a/6+a/9);

rightPanner.positionX.value = r*Math.sin(-1*a);
rightPanner.positionY.value = r*Math.cos(-1*a);
rightPanner.positionZ.value = r*Math.sin(-1*a-a/3+a/6-a/9);
} // setPosition

function updateRotator (id, value) {
const prop = id;
rotator[prop] = value;
rotator.updateRotMtx();
} // updateRotator

} // update


/// automation

function runAutomation (automation, automator) {
if (automation.enabled) {
automation.tickCount += 1;
automation.parameters.forEach(parameter => automator(audio.currentTime, parameter));
setTimeout(() => runAutomation(automation, automator), 1000 * automation.tick);

} else {
console.log("automation stopped at tick  ", automation.tickCount);
} } // enabled
// runAutomation

function automator (t, parameter) {
if (parameter && parameter.enabled) {
parameter.tickCount += 1;
//console.log("automator: ", parameter);

try {
update(parameter.name, parameter.function(t));
} catch (e) {
message(e);
update("parameterName", parameter.name);
ui("automate").checked = false;
parameter.enabled = false;
} // catch

} else if (parameter.tickCount > 0) {
console.log ("stopping automation of ", parameter.name, " at tick ", parameter.tickCount);
parameter.tickCount = 0;
} // if enabled
} // automator


function save () {
localStorage[projectName] = JSON.stringify({
name: projectName,

userValues: enumerateUiControls()
.map(element => [element.id, getValue(element.id)]),

automation: Array.from(
automation.parameters.entries()
.map(binding => binding[1].function = null)) // array.from
}); // stringify
} // save

function restore () {
try {
const project = JSON.parse(localStorage.projectName);

// set field values
project.userValues.forEach(binding => setValue(binding[0], binding[1]));

// restore automation parameters
project.automation.forEach (binding => {
const parameter = binding[1];
const p = automation.parameters.get(parameter.name);
Object.assign(p, {
function: parameter.functionText?
compile(parameter.functionText) : null
}); // assign
}); // forEach
updateAll();

} catch (e) {
console.log(`Cannot restore: ${e}.`);
//alert (`Cannot restore: ${e}.`);
} // try

} // restore


function message (...args) {
_message(args.join(", "));

function _message (text) {
document.querySelector("#message").textContent = text;
return text;
} // _message
} // message

function initializeAutomation () {
console.log("initializing automation...");
automation.defaultParameter = {
name: "",
enabled: false,
tickCount: 0,
function: null,
functionText: ""
};

automation.enabled = false;
automation.tickCount = 0;
automation.tick = 0.2; // seconds
automation.parameters = new Map();

enumerateNumericControls().forEach(element => {
automation.parameters.set(element.id, 
Object.assign({}, automation.defaultParameter, {name: element.id}));

ui("parameterName").add(
createOption(element.id, element.id)
); // add
}); // forEach

runAutomation(automation, automator);


function createOption (text) {
const option = document.createElement("option")
option.textContent = text;
option.value = text;
return option;
} // createOption 
} // initializeAutomation

function compile(text) {
try {
f = _compile(text);
f(0); // to be sure it was compiled correctly
return f;
} catch (e) {
message (`invalid function, ${e}`);
return;
} // catch

function _compile (body, parameters = "x") {
if (! body.includes("return")) body = `return (${body})`;

return new Function (parameters,
`with (Math) {${body};}`);
} // _compile
} // compile


function toCartesian(r, a) {
return [r*Math.cos(a), r*Math.sin(a)];
} // toCartesian
</script>

</body>
</html>
