<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta charset="utf-8">
<title>Phaser</title>
<style>
label {display: block;}
</style>
</head>
<body>
<h1>Phase Panner</h1>

<div id="controls">

<div id="project">
<h2>Project</h2>
<label>Project: <select id="projects" accesskey="u"></select></label>
<button id="save" accesskey="s">Save</button>
<button id="restore" accesskey="r">Restore</button>
<button id="delete">delete</button>
<br><label>project name: <input type="text" id="projectName" value="default project" accesskey="n"></label>
</div><!-- #projects -->

<div class="player">
<h2>Audio Player</h2>
<label>audio: <input type="text" id="audioFile" value="t1.mp3" accesskey="f"></label>
<button id="load" accesskey="l">Load</button>
<br><audio tabindex="0" controls accesskey="a"></audio>
</div>

<div id="parameters">
<label>bypass <input type="checkbox" id="bypass" accesskey="z"></label></div>

<div id="automation">
<h2>Automation</h2>

<label>enable automation: <input id="enableAutomation" type="checkbox" checked accesskey="g"></label>
<label>automate parameter: <select id="parameterName" accesskey="p"></select></label>
<label>function: <input type="text" id="function"></label>
<label>enable <input type="checkbox" id="automate"></label>
<label>tick: <input type="range" id="tick" value="0.2" min=".0.02" max="0.5" step="0.01"></label>

</div>

<div id="phaser">
<h2>Phaser</h2>

<label>mix: <input type="range" id="mix" value="0" min="0" max="1" step="0.1" accesskey="m"></label>
<label>configuration (series / parallel): <input type="text" id="configuration"></label>
<label>frequency: <input type="range" id="frequency" value="6000" min="40" max="10000" step="20"></label>
<label>q: <input type="range" id="q" value=".3" min="0" max="8" step="0.1" accesskey="q"></label>
<label>delay: <input type="range" id="delay" value="0.00003" min="0" max="1" step="0.000020" accesskey="d"></label>
</div>

<div id="xtc">
<h2>XTC</h2>

<label>xtc  mix: <input type="range" id="mix-xtc" value="0" min="0" max="1" step="0.1"></label>
<label>feedback: <input type="range" id="feedback" value="0" min="-1" max="1" step="0.1" accesskey="b"></label>
<label>type: <input type="text" id="type" value="bandpass"t" accesskey="t"></label>
<label>delay: <input type="range" id="delay" value="0.00003" min="0" max="1" step="0.000020" accesskey="d"></label>
</div><!-- #xtc -->

<div id="reverb">
<label>reverb mix: <input type="range" id="reverbMix" value="0" min="-1" max="1" step="0.1" accesskey="-"></label>

</div><!-- #reverb -->

<div id="limiter">
<h2>Limiter</h2>
<label>ratio: <input type="range" id="ratio" value="1" min="1" max="20"></label>
<label>threshold: <input type="range" id="threshold" value="-5.0" min="-50" max="0"></label>
<label>knee: <input type="range" id="knee" value="0" min="0" max="50"></label>
<label>attack: <input type="range" id="attack" value="0" min="0" max="50"></label>
<label>release: <input type="range" id="release" value="0" min="0" max="50"></label>
</div><!-- #limiter -->

</div><!-- #parameters -->
</div><!-- #controls -->

<div id="message" aria-live="polite"></div>

<script src="component.js"></script>
<script src="ui.js"></script>
<script>
/// Globals

const messageDisplayTime = 15; // seconds
const audio = new AudioContext();
const audioElement = document.querySelector("audio");
const player = audio.createMediaElementSource (audioElement);
const phaser = new Phaser(audio);
const xtc = new Xtc(audio);
const limiter = audio.createDynamicsCompressor();
const masterInput = audio.createGain(), masterOutput = audio.createGain();
const automation = {};
let projects = [];
let projectName = "default.txt";

/// connections
player.connect(masterInput);
masterInput.connect(phaser.input);
phaser.output.connect(masterOutput);
masterOutput.connect(limiter).connect(audio.destination);



/// initialize
initializeAutomation();
restore();
load();
updateAll();
runAutomation(automation, automator);
ui("projects").focus();



function fixNumberInputs () {
Array.from(document.querySelectorAll("input[type='number']"))
.forEach(x => x.setAttribute("aria-label", x.parentElement.textContent));
} // fixNumberInputs

function load (autoPlay) {
audioElement.src = document.querySelector("#audioFile").value;
if (autoPlay) audioElement.play();
} // load


/// events

ui("load").addEventListener("click", load);
ui("save").addEventListener("click", save);
ui("restore").addEventListener("click", restore);
ui("delete").addEventListener("click", deleteProject);

document.querySelector("#controls").addEventListener("keydown", (e) => {
if (e.key === "0" && e.target.type && e.target.type === "range") {
e.target.value = 0;
signal(e.target);
e.target.focus();
} // if

if (e.key === "Delete" && e.target.id === "projects") {
deleteProject();
setTimeout(() => e.target.focus(), 0);
} // if

if (e.key === "Enter" && e.target.type === "text") signal(e.target);

}); // special keys

document.querySelector("#controls").addEventListener("change", (e) => update(e.target.id, getValue(e.target.id)));

/// audio processing updaters

function updateAll () {
enumerateUiControls().forEach(element => update(element.id, getValue(element.id)));
} // updateAll

function updateGroup (parameter, value) {
//nsole.log(`updateGroup: ${parameter.group}, ${parameter.name}, ${value}`);
automation.groups.get(parameter.group).values.set(parameter.name, value);
} // updateGroup

function processGroups (groups) {
groups.forEach( group => {
if (group.values.size > 0) {
//console.log(`- running group ${group.name} with ${group.values.size} values; ${group.values}`);
group.function(group.values);
group.values.clear();
} // if

}); // forEach
} // processGroups



function update (id, value) {
//console.log(`update: ${id}, ${value}`);
if (!id) return;

const map = {
delete: function (id, value) {
deleteProject(ui("projects").selectedIndex);
if (projects.length > 0) {
loadProject(projects[0]);
message(`Project ${project.name} loaded.`);
} // if
},

projects: function (id, value) {
if (value) loadProject(getProject(value));
},

projectName: function (id, value) {
projectName = value;
},


threshold: limiter.threshold,
knee: limiter.knee,
ratio: limiter.ratio,
attack: limiter.attack,
release: limiter.release,
//bypass: (id, value) => bypass(value),
frequency: function (id, value) {
phaser.filters.forEach(f => f.frequency.value = value);
},
q: function (id, value) {
phaser.filters.forEach(f => f.Q.value = value);
},


delay: [phaser.delay.delayTime, xtc.leftDelay.delayTime, xtc.rightDelay.delayTime],

mix: function (id, value) {phaser.mix(value);},
"mix-xtc": function (id, value) {xtc.mix(value);},

configuration: function (id, value) {
switch (value) {
case "series": phaser.series(); return;
case "parallel": phaser.parallel(); return;
default: message(`configure: ${value} is an invalid option`); return;
} // switch
}, // configuration

enableAutomation: function (id, value) {
automation.enabled = value;
if (automation.enabled) {
console.log("starting automation...");
runAutomation(automation, automator);
} // if
}, // enableAutomation

parameterName: function (id, value) {
//console.log("selectParameter: ", value);
const parameter = automation.parameters.get(value);
display(parameter);

function display (parameter) {
ui("automate").checked = parameter.enabled;
ui("function").value = parameter.functionText;
if (parameter.enabled) message (" enabled: ");
} // displayParameter
}, // parameterName

function: function (id, value) {
const parameterName = getValue("parameterName");
const parameter = automation.parameters.get(parameterName);
parameter.functionText = value;
if (value) parameter.function = compile(value);
if (parameter.function && parameter.function instanceof Function) message ("OK.");
}, // function

automate: function (id, value) {
const parameterName = getValue("parameterName");
const parameter = automation.parameters.get(parameterName);
parameter.enabled = value;
//console.log("automate: ", value, parameter);
}, // automate
}; // map

return run(map[id], id, value);

function run (it, id, value) {
//console.log(`it: ${it}`);
if (!it) {
console.log(`run: ${id} not found`);
return;

} else if (it instanceof Array) {
//console.log(`run: processing array of length ${it.length}`);
it.forEach(object => run(object, id, value));

} else if (it instanceof Function) {
//console.log(`run: calling ${it}(${id}, ${value});`);
return it(id, value);

} else if (it instanceof Object && "value" in it) {
//console.log(`run: assigning ${it}.value = ${value}`);
it.value = value;

}else if (it instanceof Object && id in it) {
//console.log(`run: assigning ${it}.${id} = ${value}`);
it[id] = value;

} else {
console.log(`run: cannot process ${id}, ${value}`);
return;
} // if
} // run

function bypass (value) {
//console.log("bypass: ", value, id);
if (value) {
player.disconnect();
player.connect(audio.destination);
message("Bypassed...");
} else {
player.disconnect();
player.connect(masterInput);
} // if
} // bypass
} // update


/// automation

function runAutomation (automation, automator) {
if (automation.enabled) {
automation.parameters.forEach(parameter => automator(audio.currentTime, parameter));
processGroups(automation.groups);
automation.tickCount += 1;
setTimeout(() => runAutomation(automation, automator), 1000 * automation.tick);

} else {
console.log("automation stopped at tick  ", automation.tickCount);
} // enabled
} // runAutomation

function automator (t, parameter) {
if (!parameter || !parameter.enabled) return;
try {
if (!parameter.function) throw new Error(`No function to run for parameter ${parameter.name}`);

if (parameter.group) updateGroup(parameter, parameter.function(t));
else update(parameter.name, parameter.function(t));
parameter.tickCount += 1;

/*if (parameter.log) {
parameter.log.push([parameter.function(t), parameter.tickCount]);
if (parameter.log.length === 20) {
console.log (`- ${parameter.name} ${parameter.log.length}: ${parameter.log.map(x => Number(x[0]).toFixed(2))}`);
parameter.enabled = false;
} // if
} else {
parameter.log = [];
} // if
*/

} catch (e) {
update("parameterName", parameter.name);
ui("parameterName").value = parameter.name;
ui("automate").checked = false;
parameter.enabled = false;
message(`Automator: failed to automate ${parameter.name}; ${e}`);

if (parameter.tickCount > 0) {
console.log ("stopping automation of ", parameter.name, " at tick ", parameter.tickCount);
parameter.tickCount = 0;
} // if tickCount
} // catch
} // automator

/// project

function save () {
const data = createProject();
console.log("saving:", data.length, " items.");
projects = projects
.filter(p => p.name !== data.name)
.concat(data);

try {
localStorage.setItem("projects", JSON.stringify(projects));
return projects;
} catch (e) {
message(`not saved: ${e}`);
return null;
} // try
} // save

function createProject () {
return {
name: projectName,

userValues: enumerateUiControls()
.map(element => [element.id, getValue(element)]),

automation: Array.from(automation.parameters.entries())
.map(binding => Object.assign({}, binding[1], {function: null}))
}; // return
} // createProject

function restore () {
try {
const data = JSON.parse(localStorage.getItem("projects"));
if (! data) {
throw("Restore failed.");
} // if

projects = data.slice();
if (projects.length > 0) {
loadProject(projects[0]);
setTimeout(() => {
updateProjectSelector(projects);
message(`${projects.length} projects restored.`);
}, 0);
} // if

console.log("restored ", projects.map(x => x.name).join(", "));
return projects;

} catch (e) {
console.log(`Cannot restore: ${e}.`);
message(`Cannot restore: ${e}.`);
return null;
} // try
} // restore

function getProject(name) {
return projects.find(item => item.name === name);
} // getProject

function loadProject (project) {
projectName = project.name;
if (project.name) ui("projectName").value = project.name;
// set field values
project.userValues.forEach(binding => setValue(ui(binding[0]), binding[1]));

// restore automation parameters
project.automation.forEach (parameter => {
const name = parameter.name;
const value = Object.assign(
{}, 
parameter,
{function: parameter.functionText? compile(parameter.functionText) : null}
); // assign

automation.parameters.set(name, value);
}); // forEach

return project;
} // loadProject

function updateProjectSelector (data) {
populateSelector(
"projects",
data.map(p => p.name)
); // populateSelector
} // updateProjectSelector 

function deleteProject (index) {
if (index < 0 || index > projects.length) return;
delete projects[index];
projects = projects.filter(p => p); // copy, removing empty slot
updateProjectSelector(projects);
} // deleteProject

function createOption (text, value) {
const option = document.createElement("option")
option.textContent = text;
option.value = arguments.length >= 2? value : text;
return option;
} // createOption 

function message (...args) {
_message(args.join(", "));

function _message (text) {
const container = document.querySelector("#message");
container.textContent = text;
setTimeout(() => container.textContent = "", 1000 * messageDisplayTime);
return text;
} // _message
} // message

function initializeAutomation () {
automation.defaultParameter = {
name: "",
enabled: false,
tickCount: 0,
lastValue: 0,
group: "",
function: null,
functionText: ""
};

automation.enabled = false;
automation.tickCount = 0;
automation.tick = 0.2; // seconds
automation.parameters = new Map();

automation.groups = new Map([
["position", {
name: "position",
values: new Map(),
function: function (values) {
const r = values.has("radius")? values.get("radius") : getValue("radius");
const a = values.has("angle")? values.get("angle") : getValue("angle");
setPosition(a, r);
} // function
}] // position
]); // groups

enumerateNumericControls().forEach(element => {
automation.parameters.set(element.id, 
Object.assign({}, automation.defaultParameter, {
name: element.id,
group: element.getAttribute("data-group") || ""
}));
}); // forEach

populateSelector(
"parameterName", 
Array.from(automation.parameters.entries())
.map(binding => binding[0])
) // populateSelector
} // initializeAutomation

function createScene (order = 3) {
const scene = new ResonanceAudio(audio);
scene.setAmbisonicOrder(order);
return scene;
} // createScene

function createReverb (audio, scene, reverbIn, reverbOut) {
const inLeft = scene.createSource();
const inRight = scene.createSource();
const s = audio.createChannelSplitter();
reverbIn.connect(reverbDry);

reverbIn.connect(s);
s.connect(inLeft.input, 0,0);
s.connect(inRight.input, 1,0);
scene.output.connect(reverbWet);

reverbDry.connect(reverbOut);
reverbWet.connect(reverbOut);
} // createReverb

// make a room
function createRoom (scene) {

const roomDimensions = {
width: 3.1,
height: 2.5,
depth: 3.4
}; // dimensions

const roomMaterials = {
// Room wall materials
left: 'brick-bare',
right: 'curtain-heavy',
front: 'marble',
back: 'glass-thin',
// Room floor
down: 'grass',
// Room ceiling
up: 'transparent'
}; // materials

scene.setRoomProperties(roomDimensions, roomMaterials);
return scene;
} // createRoom

function compile(text) {
try {
f = _compile(text, "t");
f(0); // to be sure it was compiled correctly
return f;
} catch (e) {
message (`invalid function: ${text}\n${e}`);
return undefined;
} // catch

function _compile (body, parameters = "x") {
if (! body.includes("return")) body = `return (${body})`;

return new Function (parameters,
`with (Math) {${body};}`);
} // _compile
} // compile


function toCartesian(r, a) {
return [r*Math.cos(a), r*Math.sin(a)];
} // toCartesian
</script>

</body>
</html>
