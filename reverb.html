<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta charset="utf-8">
<title>reverb</title>
<style>
label {display: block;}
</style>
</head>

<body>
<h1>reverb test</h1>

<div id="controls">
<div id="audio">
<h2>Audio</h2>
<label>audio: <input type="text" id="media" accesskey="f"></label>
<button id="load" accesskey="l">Load</button>
<audio tabindex="0"  accesskey="a" controls></audio>
</div>

<div id="parameters">
<label>Parameter: <select id="parameterList" accesskey="p"></select></label>
value: <span class="value"></span>
<label>automation frequency: <input id="automationFrequency" type="range" value="1" min="0" max="100" step="0.1"></label>
<label>automation shape: <select id="automationShape"></select></label>
</div><!-- #parameters -->
</div><!-- #controls -->

<div id="message" aria-live="polite"></div>

<script src="resonance-audio.min.js"></script>
<script src="ui.js"></script>
<script src="component.js"></script>
<script src="reverb.js"></script>
<script src="parameters.js"></script>
<script src="parameterData.js"></script>
<script>
const messageDisplayTime = 20; // seconds
const audio = new AudioContext();
const audioElement = document.querySelector("audio");
const player = audio.createMediaElementSource (audioElement);
const scene = Reverb.createScene();
const reverb = new Reverb(audio, scene);
const room = Reverb.defaultRoom();
const projectList = [];
const project = {};

reverb.updateRoom(room);
reverb.setPosition(
[-room.dimensions.width/2,0,0],
[room.dimensions.width/2,0,0]
); // initial position
reverb.source.left.setOrientation(1,0,0, 0,1,0);
reverb.source.right.setOrientation(-1,0,0, 0,1,0);
[reverb.source.left, reverb.source.right].forEach(source => source.setRolloff("none"));

/// connections
player.connect(reverb.input);
reverb.output.connect(audio.destination);


/// initialize

const parameters = createParameterMap(parameterData);
console.log(`created ${parameters.size} parameters`);
populateSelector (
ui("parameterList"),
Array.from(parameters.keys()).filter(key => {
const parameter = parameters.get(key);
return (parameter.list && parameter.updater);
}) // filter
); // populateSelector

populateSelector(ui("automationShape"), "sine, square, sawtooth, triangle".split(", "));

/// events

ui("controls").addEventListener("change",
e => update(e.target.value,
e.target.id? e.target.id : getParameterName(),
e.target)
);

ui("controls").addEventListener("keydown", (e) => {
if (e.key === "0" && e.target.type && e.target.type === "range") {
e.target.value = 0;
signal(e.target);
e.target.focus();

} else if (e.key === "Enter" && e.target.type === "text") {
signal(e.target);

} else if (e.target.tagName.toLowerCase() === "button" && e.key.includes("Arrow")) {
let value = e.target.getAttribute("data-value");
console.log("parsing ", value);
try {
value = JSON.parse(value);
} catch (e) {
message(`${e}\n${e.stack}`);
return;
} // try

switch (e.key) {
case "ArrowUp": value = modify(value, 1, 1); break;
case "ArrowDown": value = modify(value, 1, -1); break;

case "ArrowLeft": value = modify(value, 0, -1); break;
case "ArrowRight": value = modify(value, 0, 1); break;
default: return;
} // switch

e.target.setAttribute("data-value", JSON.stringify(value));
e.preventDefault();
signal(e.target);
console.log("- new value ", value);
} // if
}); // special keys


/// updating

function update (value, parameterName, element) {
console.log("update: ", value, parameterName);
if (! parameterName) return;
const parameter = parameters.get(
parameters.has(parameterName)?
parameterName : getParameterName()
); // parameters.get
console.log("- parameter: ", parameter.name, " is type ", parameter.type);

value = value.trim();
if (parameter.type === "range" || parameter.type === "number") {
value = Number(value);
} else if (parameter.type === "custom") {
value = element.getAttribute("data-value");
} // if	

// cache values
parameter.value = value;
parameter.selectedIndex = element.selectedIndex;

if (parameter && parameter.updater) {
run(parameter.updater, value);
} // if


function run(updater, value) {
if (!updater) return;
if (updater instanceof Function) {
try {updater (value);}
catch (e) {message(`OOPS: ${e}`);}

} else if (typeof(updater) === "object" && !(updater instanceof Array)) {

// special cases
// if updater has a key of "value", then assign value to that key
if ("value" in updater) updater.value = value;
// else if element has an id whose value is a key in updater, then assign value to that key
else if (element && element.id && element.id in updater) updater[element.id] = value;
else throw new Error(`cannot update: ${parameter.name} to ${value} with ${updater}`);

} else if (updater instanceof Array) {
updater.forEach(updater => run(updater, value));
} // if
} // run
} // update

function displayParameter (parameter) {
console.log(`displaying ${parameter.name}...`);
const element = createUiControl(parameter);
const container = document.querySelector("#parameters .value");
container.innerHTML = "";
container.appendChild(element);
applyConstraints(container, element, parameter);
message(`${parameter.name}: ${parameter.value}`);
} // displayParameter

function applyConstraints (container, element, parameter) {
container.removeAttribute("role");

if (parameter.type === "custom") {
if (parameter.role) container.setAttribute("role", parameter.role);
} // if
} // applyConstraints

function getParameterName () {
return ui("parameterList").value;
} // getParameterName


function modify(vector, index, n) {
if (vector instanceof Array) {
vector = vector.slice();
if (index >= 0 && index < vector.length) {
vector[index] += n;
} else {
message(`index must be between 0 and ${vector.length-1}`);
} // if

} else {
message(`first argument must be a vector`);
} // if

return vector;
} // modify

function message (...args) {
_message(args.join(", "));

function _message (text) {
const container = document.querySelector("#message");
container.textContent = text;
setTimeout(() => container.textContent = "", 1000 * messageDisplayTime);
return text;
} // _message
} // message

</script>

</body>
</html>
