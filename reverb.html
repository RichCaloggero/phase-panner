<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta charset="utf-8">
<title>reverb</title>
<style>
label {display: block;}
</style>
</head>

<body>
<h1>reverb test</h1>

<div id="controls">
<div>
<h2>Project</h2>
<label>Project: <select id="projectList" accesskey="u"></select></label>
<button id="restore" accesskey="r">Restore</button>
<button id="save" accesskey="s">Save</button>
<button id="delete" accesskey="-">Delete</button>
<label>Name: <input type="text" id="projectName" accesskey="n"></label>
</div>

<div id="parameters">
<div id="audio">
<h2>Audio</h2>
<label>audio: <input type="text" id="media" accesskey="f"></label>
<button id="load" accesskey="l">Load</button>
<audio tabindex="0"  accesskey="a" controls></audio>
</div>

<label>Parameter: <select id="parameterList" accesskey="p"></select></label>
<span class="value"></span>
<label>automation function: <input id="automationFunction" type="text" value="sin(t)"></label>
<label>enable automation: <input id="enableAutomation" type="checkbox" accesskey="e"></label>
<label>automation frequency: <input id="automationFrequency" type="range" value="1" min="0" max="100" step="0.1"></label>
<label>automation shape: <select id="automationShape"></select></label>
<label>run automation: <input id="runAutomation" type="checkbox" checked accesskey="r"></label>
</div><!-- #parameters -->

<div id="output">
<label>Volume: <input id="volume" type="range" min="0" max="1" step="0.1" accesskey="v"></label>
</div><!-- #output -->
</div><!-- #controls -->

<div id="message" aria-live="polite"></div>

<script src="resonance-audio.min.js"></script>
<script src="ui.js"></script>
<script src="component.js"></script>
<script  src="reverb.js">
window.Reverb = Reverb;
</script>
<script src="parameters.js"></script>
<script src="parameterData.js"></script>
<script>
"use strict";

const messageDisplayTime = 20; // seconds
const audio = new AudioContext();
const audioElement = document.querySelector("audio");
const input = audio.createGain();
const output = audio.createGain();
const player = audio.createMediaElementSource (audioElement);
const scene = createScene();
const reverb = new Reverb(audio, scene);
const room = Reverb.defaultRoom();
const xtc = new Xtc(audio);
const projectList = [];
let projectName = "Untitled Project";
let tickCount = 0;
let automationEnabled = true;

/// connections
player.connect(input);
input.connect(reverb.input);
reverb.output.connect(xtc.input);
xtc.output.connect(output).connect(audio.destination);


/// initialize

const parameters = createParameterMap(parameterData);
//console.log(`created ${parameters.size} parameters`);
populateSelector (
ui("parameterList"),
Array.from(parameters.keys())
.filter(key => {
const parameter = parameters.get(key);
return (parameter.list && parameter.updater);
}) // filter
); // populateSelector

populateSelector(ui("automationShape"), "sine, square, sawtooth, triangle".split(", "));

reverb.source.left.setOrientation(1,0,0, 0,1,0);
reverb.source.right.setOrientation(-1,0,0, 0,1,0);
[reverb.source.left, reverb.source.right].forEach(source => source.setRolloff("none"));

restore();
updateAll();
_update(parameters.get("projectList"));
ui("projectList").focus();
if (automationEnabled) runAutomation(automator);

console.log("initialization complete.");


/// events

ui("save").addEventListener("click", save);
ui("restore").addEventListener("click", restore);
ui("delete").addEventListener("click", e => deleteProject(getProjectName()));
ui("controls").addEventListener("click", e => {
if (e.target.matches("button.vector")) {
message (e.target.getAttribute("data-value"));
} // if
});



ui("controls").addEventListener("change", e => {
//console.log("change event on ", e.target.id);
update(e.target)
});

ui("controls").addEventListener("keydown", (e) => {
if (e.key === "Delete" && e.target.id === "projectList") {
deleteProject(e.target.value);
setTimeout(() => e.target.focus(), 0);

} else if ((e.key === "0" || e.key === "1") && e.target.type && e.target.type === "range") {
e.target.value = e.key;
signal(e.target);
e.target.focus();

} else if (e.key === "0" && e.target.classList.contains("vector")) {
e.target.setAttribute("data-value", "[0,0,0]");

} else if (e.key === "Enter" && e.target.type === "text") {
signal(e.target);

} else if (e.key.includes("Arrow") && e.target.matches("button.vector")) {
const parameter = parameters.get(getParameterName());
let value = e.target.getAttribute("data-value");
let delta = parameter.step;

try {
value = JSON.parse(value);
} catch (e) {
message(`${e}\n${e.stack}`);
return;
} // try

switch (e.key) {
case "ArrowUp": value = modify(value, 2, delta); break;
case "ArrowDown": value = modify(value, 2, -1*delta); break;

case "ArrowLeft": value = modify(value, 0, -1*delta); break;
case "ArrowRight": value = modify(value, 0, delta); break;
default: return;
} // switch

e.target.setAttribute("data-value", JSON.stringify(value));
e.preventDefault();
signal(e.target);
//console.log("- new value ", value);
} // if
}); // special keys


/// updating

function updateAll () {
parameters.forEach(parameter => {
if (parameter.list && parameter.name !== "dimensions" && parameter.name !== "rotate") _update(parameter);
});
} // updateAll

function update (element) {
console.log(`update: ${element.id}, ${element.type}, ${element.value}, ${element.checked}`);
const parameterName = (element.id === "value")?
getParameterName() : element.id;
if (! parameterName) return;
const parameter = parameters.get(parameterName);
console.log("- parameter: ", parameter.name, " is type ", parameter.type);

let value = element.value.trim();
if (parameter.type === "range" || parameter.type === "number") {
value = Number(value);
} else if (parameter.type === "checkbox") {
value = element.checked;
} else if (parameter.type === "custom") {
value = element.getAttribute("data-value");
} // if	
//console.log(`- ${parameter.name}, updates via ${typeof(parameter.updater)} with ${typeof(value)}, ${value}`);

// cache values
parameter.value = value;
parameter.selectedIndex = element.selectedIndex;

if (parameter && parameter.updater) {
_update(parameter);
} // if

return element;
} // update


function _update (parameter) {
//console.log(`_update: ${parameter.name}`);
const updater = parameter.updater;
if (!updater) return;
const value = parameter.options? parameter.options[parameter.selectedIndex] : parameter.value;

if (updater instanceof Function) {
try {updater (value);}
catch (e) {message(
`OOPS: ${e}
${e.stack}
`);} // catch

/*} else if (typeof(updater) === "object" && !(updater instanceof Array)) {

// special cases
// if updater has a key of "value", then assign value to that key
if ("value" in updater) updater.value = value;
// else if element has an id whose value is a key in updater, then assign value to that key
else if (element && element.id && element.id in updater) updater[element.id] = value;
else throw new Error(`cannot update: ${parameter.name} to ${value} with ${updater}`);

} else if (updater instanceof Array) {
updater.forEach(updater => run(updater, value));
*/
} // if
} // _update

function displayParameter (parameter) {
//console.log(`displaying ${parameter.name}...`);
const element = createUiControl(parameter);
const container = document.querySelector("#parameters .value");
container.innerHTML = "";
container.removeAttribute("role");

if (parameter.type === "custom") {
container.appendChild(element);
if (parameter.role) container.setAttribute("role", parameter.role);

} else {
const label = document.createElement("label");
label.textContent = parameter.label || parameter.name;
label.appendChild(element);
container.appendChild(label);
} // if
//setTimeout(() => {
message(`${parameter.name}: ${element.value}`);
//}, 50);
} // displayParameter

/// projects

function save () {
updateProjectList(createProject());
console.log("save: first project name is ", projectList[0].name);
localStorage.setItem("reverb", JSON.stringify(projectList));
message(`Saved ${projectList.length} projects.`);
} // save

function restore () {
try {
const list = JSON.parse(localStorage.getItem("reverb"));
projectList = list;
console.log(`restoring ${list.length} items...`);
populateSelector(ui("projectList"), list.map(p => p.name));
console.log("- project selector initialized");
if (findProject(projectName)) {
loadProject(projectName);
} else if (projectList.length > 0) {
loadProject(list[0].name);
} // if

} catch (e) {
message(`restore: error; ${e}`);
} // try

message(`${projectList.length} projects restored.`);
} // restore

function createProject () {
return {
name: projectName || "Untitled Project"		,
parameters: saveParameters()
};
} // createProject

function loadProject (name) {
if (! name) {
message("loadProject: need a name");
throw new Error("loadProject: need a name");
} // if

const project = projectList[findProject(name)];
if (project) {
projectName = project.name;
parameters = restoreParameters(project.parameters);
ui("projectList").selectedIndex = findProject(name);
message (`${project.name} loaded.`);

} else {
message(`load: project ${name} does not exist`);
return;
} // if
} // loadProject

function findProject (name) {
return projectList.findIndex(p => compareNames(name, p.name));
} // findProject

function updateProjectList (project) {
let index = projectList.findIndex(p => p.name === project.name);
if (index >= 0) {
projectList[index] = project;
} else {
projectList.push(project);
} // if
} // updateProjectList

function setPosition (a, r) {
const pi = Math.PI;
const cos = Math.cos;
const sin = Math.sin;
a = (pi / 180) * a;

reverb.source.left.setPosition(
-1 * r * cos(a),
r * sin(a),
r * sin(a) * cos(a)
);

reverb.source.right.setPosition(
r * cos(a),
r * sin(a),
-1 * r * sin(a) * cos(a)
);
} // setPosition

/// automation

function runAutomation (automator, tick = 0.1) {
if (automationEnabled) {
parameters.forEach(parameter => {
if (parameter.automation.enabled && parameter.automation.function) automator(audio.currentTime, parameter);
}); // forEach

//processGroups(automation.groups);
tickCount += 1;

if (automationEnabled) setTimeout(() => runAutomation(automator, tick), 1000 * tick);

} else {
console.log("automation stopped at tick  ", tickCount);
} // enabled
} // runAutomation

function automator (t, parameter) {
if (!parameter || !parameter.automation.enabled) return;
try {
if (!parameter.automation.function) throw new Error(`No function to run for parameter ${parameter.name}`);

parameter.value = parameter.automation.function(t);
_update(parameter);

//if (parameter.group) updateGroup(parameter, parameter.function(t));
//else update(parameter.name, parameter.function(t));

parameter.tickCount += 1;

} catch (e) {
message(`Automator: failed to automate ${parameter.name}; ${e}`);

if (parameter.automation.tickCount > 0) {
console.log ("stopping automation of ", parameter.name, " at tick ", parameter.automation.tickCount);
parameter.automation.tickCount = 0;
} // if tickCount
} // catch
} // automator


/// utilities


function LFO (frequency, shape) {
const oscillator = audio.createOscillator();
oscillator.frequency.value = frequency;
oscillator.shape.value = shape;
return oscillator;
} // LFO

function compareNames (name1, name2) {
return removeSpaces(name1) === removeSpaces(name2);
} // compareNames

function removeSpaces (s) {
s.replace(/\s/g, "");
} // removeSpaces

function getProjectName () {
return ui("projectList").value;
} // getProjectName

function getParameterName () {
return ui("parameterList").value;
} // getParameterName

function saveParameters () {
return Array.from(parameters.entries());
} // saveParameters

function restoreParameters (entries) {
entries.forEach(entry => {
const old = parameters.get(entry[0]);
const newData = entry[1];
Object.assign(old, newData);
});
} // restoreParameters


function modify(vector, index, n) {
if (vector instanceof Array) {
vector = vector.slice();
if (index >= 0 && index < vector.length) {
vector[index] += n;
} else {
message(`index must be between 0 and ${vector.length-1}`);
} // if

} else {
message(`first argument must be a vector`);
} // if

return vector;
} // modify

function message (...args) {
_message(args.join(", "));

function _message (text) {
const container = document.querySelector("#message");
container.textContent = text;
if (messageDisplayTime > 0) setTimeout(() => container.textContent = "", 1000 * messageDisplayTime);
return text;
} // _message
} // message

function createScene (order = 3) {
const scene = new ResonanceAudio(audio);
scene.setAmbisonicOrder(order);
return scene;
} // createScene

function compile(text) {
try {
const f = _compile(text, "t");
f(0); // to be sure it was compiled correctly
return f;
} catch (e) {
message (`invalid function: ${text}\n${e}`);
return undefined;
} // catch

function _compile (body, parameters = "x") {
if (! body) return null;
if (! body.includes("return")) body = `return (${body})`;

return new Function (
parameters,
`with (Math) {
${body};
}`
); // new Function
} // _compile
} // compile

</script>

</body>
</html>
