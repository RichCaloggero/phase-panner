<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta charset="utf-8">
<title>reverb</title>
<style>
label {display: block;}
</style>
</head>

<body>
<h1>reverb test</h1>

<div id="controls">
<div id="audio">
<h2>Audio</h2>
<label>audio: <input type="text" id="media" accesskey="f"></label>
<button id="load" accesskey="l">Load</button>
<audio tabindex="0"  accesskey="a" controls></audio>
</div>

<div id="parameters">
<label>Parameter: <select id="parameterList" accesskey="p"></select></label>
value: <span class="value"></span>
<label>automation frequency: <input id="automationFrequency" type="range" value="1" min="0" max="100" step="0.1"></label>
<label>automation shape: <select id="automationShape"></select></label>
</div><!-- #parameters -->
</div><!-- #controls -->

<div id="message" aria-live="polite"></div>

<script src="resonance-audio.min.js"></script>
<script src="ui.js"></script>
<script src="component.js"></script>
<script src="reverb.js"></script>
<script src="parameters.js"></script>
<script src="parameterData.js"></script>
<script>
const messageDisplayTime = 20; // seconds
const audio = new AudioContext();
const audioElement = document.querySelector("audio");
const player = audio.createMediaElementSource (audioElement);
const scene = Reverb.createScene();
const reverb = new Reverb(audio, scene);
const room = Reverb.defaultRoom();
const projectList = [];
const project = {};

/// connections
player.connect(reverb.input);
reverb.output.connect(audio.destination);


/// initialize

const parameters = createParameterMap(parameterData);
//console.log(`created ${parameters.size} parameters`);
populateSelector (
ui("parameterList"),
Array.from(parameters.keys()).filter(key => {
const parameter = parameters.get(key);
return (parameter.list && parameter.updater);
}) // filter
); // populateSelector

populateSelector(ui("automationShape"), "sine, square, sawtooth, triangle".split(", "));

reverb.source.left.setOrientation(1,0,0, 0,1,0);
reverb.source.right.setOrientation(-1,0,0, 0,1,0);
[reverb.source.left, reverb.source.right].forEach(source => source.setRolloff("none"));

updateAll();
update(ui("parameterList")).focus();
console.log("initialization complete.");

/*reverb.updateRoom(room);
reverb.setPosition(
[-room.dimensions.width/2,0,0],
[room.dimensions.width/2,0,0]
); // initial position
*/


/// events

ui("controls").addEventListener("change", e => {
console.log("change event on ", e.target.id);
update(e.target)
});

ui("controls").addEventListener("keydown", (e) => {
if ((e.key === "0" || e.key === "1") && e.target.type && e.target.type === "range") {
e.target.value = e.key;
signal(e.target);
e.target.focus();

} else if (e.key === "0" && e.target.classList.contains("vector")) {
e.target.setAttribute("data-value", "[0,0,0]");

} else if (e.key === "Enter" && e.target.type === "text") {
signal(e.target);

} else if (e.key.includes("Arrow") && e.target.matches("button.vector")) {
const parameter = parameters.get(getParameterName());
let value = e.target.getAttribute("data-value");
let delta = parameter.step;

try {
value = JSON.parse(value);
} catch (e) {
message(`${e}\n${e.stack}`);
return;
} // try

switch (e.key) {
case "ArrowUp": value = modify(value, 2, delta); break;
case "ArrowDown": value = modify(value, 2, -1*delta); break;

case "ArrowLeft": value = modify(value, 0, -1*delta); break;
case "ArrowRight": value = modify(value, 0, delta); break;
default: return;
} // switch

e.target.setAttribute("data-value", JSON.stringify(value));
e.preventDefault();
signal(e.target);
//console.log("- new value ", value);
} // if
}); // special keys


/// updating

function updateAll () {
parameters.forEach(parameter => {
if (parameter.list && parameter.name !== "dimensions" && parameter.name !== "rotate") _update(parameter);
});
} // updateAll

function update (element) {
console.log("update: ", element);
const parameterName = element.id || getParameterName();
if (! parameterName) return;
const parameter = parameters.get(parameterName);
console.log("- parameter: ", parameter.name, " is type ", parameter.type);

let value = element.value.trim();
if (parameter.type === "range" || parameter.type === "number") {
value = Number(value);
} else if (parameter.type === "custom") {
value = element.getAttribute("data-value");
} // if	
console.log(`- ${parameter.name}, ${typeof(value)}, ${value}`);

// cache values
parameter.value = value;
parameter.selectedIndex = element.selectedIndex;

if (parameter && parameter.updater) {
_update(parameter);
} // if

return element;
} // update


function _update (parameter) {
//console.log(`_update: ${parameter.name}`);
const updater = parameter.updater;
if (!updater) return;
const value = parameter.options? parameter.options[parameter.selectedIndex] : parameter.value;
//console.log(`- ${typeof(updater)}, ${value}`);

if (updater instanceof Function) {
try {updater (value);}
catch (e) {message(`OOPS: ${e}\n${e.stack}`);}

} else if (typeof(updater) === "object" && !(updater instanceof Array)) {

// special cases
// if updater has a key of "value", then assign value to that key
if ("value" in updater) updater.value = value;
// else if element has an id whose value is a key in updater, then assign value to that key
else if (element && element.id && element.id in updater) updater[element.id] = value;
else throw new Error(`cannot update: ${parameter.name} to ${value} with ${updater}`);

} else if (updater instanceof Array) {
updater.forEach(updater => run(updater, value));
} // if
} // _update

function displayParameter (parameter) {
//console.log(`displaying ${parameter.name}...`);
const element = createUiControl(parameter);
const container = document.querySelector("#parameters .value");
container.innerHTML = "";
container.appendChild(element);
applyConstraints(container, element, parameter);
message(`${parameter.name}: ${parameter.value}`);
} // displayParameter

function applyConstraints (container, element, parameter) {
container.removeAttribute("role");

if (parameter.type === "custom") {
if (parameter.role) container.setAttribute("role", parameter.role);
} // if
} // applyConstraints

function getParameterName () {
return ui("parameterList").value;
} // getParameterName


function modify(vector, index, n) {
if (vector instanceof Array) {
vector = vector.slice();
if (index >= 0 && index < vector.length) {
vector[index] += n;
} else {
message(`index must be between 0 and ${vector.length-1}`);
} // if

} else {
message(`first argument must be a vector`);
} // if

return vector;
} // modify

function message (...args) {
_message(args.join(", "));

function _message (text) {
const container = document.querySelector("#message");
container.textContent = text;
setTimeout(() => container.textContent = "", 1000 * messageDisplayTime);
return text;
} // _message
} // message

</script>

</body>
</html>
